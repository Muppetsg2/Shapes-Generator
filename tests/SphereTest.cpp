#include "pch.hpp"
#include "Vertex.hpp"
#include "Shape.hpp"
#include "Sphere.hpp"

#include "Helpers.hpp"

#include <vector>

#include <catch2/catch_test_macros.hpp>

class TestableSphere : public Sphere {
public:
    using Sphere::Sphere;
    const std::vector<Vertex>& getVertices() const { return _vertices; }
    const std::vector<unsigned int>& getIndices() const { return _indices; }
};

TEST_CASE("ShapesGenerator.Sphere.Generation(H3V3FLAT)") {
    static const std::vector<Vertex> expectedVertices = {
        //POSITION						//TEX COORD		//NORMAL					//TANGENT					//BITANGENT
		{ { 0.75f, 0.5f, -0.433013f }, { 0.333333f, 0.333333f }, { 0.344124f, 0.917663f, 0.19868f }, { 0.5f, -0.f, -0.866025f }, { 0.686243f, -0.304997f, -0.660338f } },
		{ { 0.f, 1.f, 0.f }, { 0.5f, 0.f }, { 0.344124f, 0.917663f, 0.19868f }, { 0.5f, -0.f, -0.866025f }, { 0.686243f, -0.304997f, -0.660338f } },
		{ { 0.f, 0.5f, 0.866025f }, { 0.f, 0.333333f }, { 0.344124f, 0.917663f, 0.19868f }, { 0.5f, -0.f, -0.866025f }, { 0.686243f, -0.304997f, -0.660338f } },
		{ { 0.75f, -0.5f, -0.433013f }, { 0.333333f, 0.666667f }, { 0.344123f, -0.917663f, 0.19868f }, { 0.5f, -0.f, -0.866025f }, { -0.686244f, -0.304997f, 0.660338f } },
		{ { 0.f, -0.5f, 0.866025f }, { 0.f, 0.666667f }, { 0.344123f, -0.917663f, 0.19868f }, { 0.5f, -0.f, -0.866025f }, { -0.686244f, -0.304997f, 0.660338f } },
		{ { 0.f, -1.f, 0.f }, { 0.5f, 1.f }, { 0.344123f, -0.917663f, 0.19868f }, { 0.5f, -0.f, -0.866025f }, { -0.686244f, -0.304997f, 0.660338f } },
		{ { -0.75f, 0.5f, -0.433013f }, { 0.666667f, 0.333333f }, { -0.f, 0.917663f, -0.39736f }, { -1.f, -0.f, 0.f }, { -0.f, -0.755929f, -0.654654f } },
		{ { 0.f, 1.f, 0.f }, { 0.5f, 0.f }, { -0.f, 0.917663f, -0.39736f }, { -1.f, -0.f, 0.f }, { -0.f, -0.755929f, -0.654654f } },
		{ { 0.75f, 0.5f, -0.433013f }, { 0.333333f, 0.333333f }, { -0.f, 0.917663f, -0.39736f }, { -1.f, -0.f, 0.f }, { -0.f, -0.755929f, -0.654654f } },
		{ { -0.75f, -0.5f, -0.433012f }, { 0.666667f, 0.666667f }, { -0.f, -0.917663f, -0.39736f }, { -1.f, -0.f, 0.f }, { -0.f, -0.755929f, 0.654654f } },
		{ { 0.75f, -0.5f, -0.433013f }, { 0.333333f, 0.666667f }, { -0.f, -0.917663f, -0.39736f }, { -1.f, -0.f, 0.f }, { -0.f, -0.755929f, 0.654654f } },
		{ { 0.f, -1.f, 0.f }, { 0.5f, 1.f }, { -0.f, -0.917663f, -0.39736f }, { -1.f, -0.f, 0.f }, { -0.f, -0.755929f, 0.654654f } },
		{ { 0.f, 0.5f, 0.866025f }, { 1.f, 0.333333f }, { -0.344124f, 0.917663f, 0.19868f }, { 0.5f, -0.f, 0.866025f }, { -0.686244f, -0.304997f, -0.660338f } },
		{ { 0.f, 1.f, 0.f }, { 0.5f, 0.f }, { -0.344124f, 0.917663f, 0.19868f }, { 0.5f, -0.f, 0.866025f }, { -0.686244f, -0.304997f, -0.660338f } },
		{ { -0.75f, 0.5f, -0.433013f }, { 0.666667f, 0.333333f }, { -0.344124f, 0.917663f, 0.19868f }, { 0.5f, -0.f, 0.866025f }, { -0.686244f, -0.304997f, -0.660338f } },
		{ { 0.f, -0.5f, 0.866025f }, { 1.f, 0.666667f }, { -0.344124f, -0.917663f, 0.19868f }, { 0.5f, -0.f, 0.866025f }, { 0.686244f, -0.304997f, 0.660338f } },
		{ { -0.75f, -0.5f, -0.433012f }, { 0.666667f, 0.666667f }, { -0.344124f, -0.917663f, 0.19868f }, { 0.5f, -0.f, 0.866025f }, { 0.686244f, -0.304997f, 0.660338f } },
		{ { 0.f, -1.f, 0.f }, { 0.5f, 1.f }, { -0.344124f, -0.917663f, 0.19868f }, { 0.5f, -0.f, 0.866025f }, { 0.686244f, -0.304997f, 0.660338f } },
		{ { 0.75f, 0.5f, -0.433013f }, { 0.333333f, 0.333333f }, { 0.474342f, 0.316228f, 0.821584f }, { 0.5f, -0.f, -0.866025f }, { -0.f, -1.f, -0.f } },
		{ { 0.f, 0.5f, 0.866025f }, { 0.f, 0.333333f }, { 0.474342f, 0.316228f, 0.821584f }, { 0.5f, -0.f, -0.866025f }, { -0.f, -1.f, -0.f } },
		{ { 0.f, -0.5f, 0.866025f }, { 0.f, 0.666667f }, { 0.474342f, 0.316228f, 0.821584f }, { 0.5f, -0.f, -0.866025f }, { -0.f, -1.f, -0.f } },
		{ { 0.75f, -0.5f, -0.433013f }, { 0.333333f, 0.666667f }, { 0.948683f, -0.316228f, -0.f }, { 0.5f, -0.f, -0.866025f }, { -0.f, -1.f, 0.f } },
		{ { 0.75f, 0.5f, -0.433013f }, { 0.333333f, 0.333333f }, { 0.948683f, -0.316228f, -0.f }, { 0.5f, -0.f, -0.866025f }, { -0.f, -1.f, 0.f } },
		{ { 0.f, -0.5f, 0.866025f }, { 0.f, 0.666667f }, { 0.948683f, -0.316228f, -0.f }, { 0.5f, -0.f, -0.866025f }, { -0.f, -1.f, 0.f } },
		{ { -0.75f, 0.5f, -0.433013f }, { 0.666667f, 0.333333f }, { 0.474342f, 0.316228f, -0.821584f }, { -1.f, -0.f, 0.f }, { -0.f, -1.f, 0.f } },
		{ { 0.75f, 0.5f, -0.433013f }, { 0.333333f, 0.333333f }, { 0.474342f, 0.316228f, -0.821584f }, { -1.f, -0.f, 0.f }, { -0.f, -1.f, 0.f } },
		{ { 0.75f, -0.5f, -0.433013f }, { 0.333333f, 0.666667f }, { 0.474342f, 0.316228f, -0.821584f }, { -1.f, -0.f, 0.f }, { -0.f, -1.f, 0.f } },
		{ { -0.75f, -0.5f, -0.433012f }, { 0.666667f, 0.666667f }, { -0.474342f, -0.316228f, -0.821584f }, { -1.f, -0.f, 0.f }, { 0.f, -1.f, 0.f } },
		{ { -0.75f, 0.5f, -0.433013f }, { 0.666667f, 0.333333f }, { -0.474342f, -0.316228f, -0.821584f }, { -1.f, -0.f, 0.f }, { 0.f, -1.f, 0.f } },
		{ { 0.75f, -0.5f, -0.433013f }, { 0.333333f, 0.666667f }, { -0.474342f, -0.316228f, -0.821584f }, { -1.f, -0.f, 0.f }, { 0.f, -1.f, 0.f } },
		{ { 0.f, 0.5f, 0.866025f }, { 1.f, 0.333333f }, { -0.948683f, 0.316228f, 0.f }, { 0.5f, -0.f, 0.866025f }, { 0.f, -1.f, -0.f } },
		{ { -0.75f, 0.5f, -0.433013f }, { 0.666667f, 0.333333f }, { -0.948683f, 0.316228f, 0.f }, { 0.5f, -0.f, 0.866025f }, { 0.f, -1.f, -0.f } },
		{ { -0.75f, -0.5f, -0.433012f }, { 0.666667f, 0.666667f }, { -0.948683f, 0.316228f, 0.f }, { 0.5f, -0.f, 0.866025f }, { 0.f, -1.f, -0.f } },
		{ { 0.f, -0.5f, 0.866025f }, { 1.f, 0.666667f }, { -0.474342f, -0.316228f, 0.821584f }, { 0.5f, -0.f, 0.866025f }, { -0.f, -1.f, -0.f } },
		{ { 0.f, 0.5f, 0.866025f }, { 1.f, 0.333333f }, { -0.474342f, -0.316228f, 0.821584f }, { 0.5f, -0.f, 0.866025f }, { -0.f, -1.f, -0.f } },
		{ { -0.75f, -0.5f, -0.433012f }, { 0.666667f, 0.666667f }, { -0.474342f, -0.316228f, 0.821584f }, { 0.5f, -0.f, 0.866025f }, { -0.f, -1.f, -0.f } }
    };

    static const std::vector<unsigned int> expectedIndices = {
		0, 1, 2,
		3, 4, 5,
		6, 7, 8,
		9, 10, 11,
		12, 13, 14,
		15, 16, 17,
		18, 19, 20,
		21, 22, 23,
		24, 25, 26,
		27, 28, 29,
		30, 31, 32,
		33, 34, 35
    };

    TestableSphere* sphere = new TestableSphere(3u, 3u, SphereShading::FLAT, ValuesRange::ONE_TO_ONE);

    const auto& v = sphere->getVertices();
    const auto& i = sphere->getIndices();

    REQUIRE(v.size() == expectedVertices.size());
    REQUIRE(i.size() == expectedIndices.size());

    for (size_t idx = 0; idx < v.size(); ++idx) {
		CheckVec3Equal(v[idx].Position, expectedVertices[idx].Position, TEST_EPSILON, "Position");
		CheckVec2Equal(v[idx].TexCoord, expectedVertices[idx].TexCoord, TEST_EPSILON, "TexCoord");
		CheckVec3Equal(v[idx].Normal, expectedVertices[idx].Normal, TEST_EPSILON, "Normal");
		CheckVec3Equal(v[idx].Tangent, expectedVertices[idx].Tangent, TEST_EPSILON, "Tangent");
		CheckVec3Equal(v[idx].Bitangent, expectedVertices[idx].Bitangent, TEST_EPSILON, "Bitangent");
    }

    for (size_t idx = 0; idx < i.size(); ++idx) {
        REQUIRE(i[idx] == expectedIndices[idx]);
    }
}

TEST_CASE("ShapesGenerator.Sphere.Generation(H4V4SMOOTH)") {
	static const std::vector<Vertex> expectedVertices = {
		//POSITION						//TEX COORD		//NORMAL					//TANGENT					//BITANGENT
		{ { 0.f, 1.f, 0.f }, { 0.5f, 0.f }, { 0.f, 1.f, 0.f }, { -0.f, 0.f, 0.f }, { -0.f, -0.382683f, -0.92388f } },
		{ { 0.f, 0.707107f, 0.707107f }, { 0.f, 0.25f }, { 0.f, 0.707107f, 0.707107f }, { 0.707107f, 0.f, -0.707107f }, { 0.621876f, -0.782076f, -0.04034f } },
		{ { 0.707107f, 0.707107f, -0.f }, { 0.25f, 0.25f }, { 0.707107f, 0.707107f, -0.f }, { 0.196116f, 0.f, -0.980581f }, { 0.427558f, -0.867282f, -0.254983f } },
		{ { -0.f, 0.707107f, -0.707107f }, { 0.5f, 0.25f }, { -0.f, 0.707107f, -0.707107f }, { -0.980581f, 0.f, -0.196116f }, { 0.086693f, -0.801277f, -0.59198f } },
		{ { -0.707107f, 0.707107f, 0.f }, { 0.75f, 0.25f }, { -0.707107f, 0.707107f, 0.f }, { -0.196116f, 0.f, 0.980581f }, { -0.400263f, -0.811914f, -0.424953f } },
		{ { 0.f, 0.707107f, 0.707107f }, { 1.f, 0.25f }, { 0.f, 0.707107f, 0.707107f }, { 0.707107f, 0.f, 0.707107f }, { -0.52788f, -0.848984f, -0.02386f } },
		{ { 0.f, -0.f, 1.f }, { 0.f, 0.5f }, { 0.f, -0.f, 1.f }, { 0.707107f, 0.f, -0.707107f }, { 0.136774f, -0.990602f, -0.f } },
		{ { 1.f, -0.f, -0.f }, { 0.25f, 0.5f }, { 1.f, -0.f, -0.f }, { -0.f, 0.f, -1.f }, { -0.f, -0.990602f, -0.136774f } },
		{ { -0.f, -0.f, -1.f }, { 0.5f, 0.5f }, { -0.f, -0.f, -1.f }, { -1.f, 0.f, 0.f }, { -0.136774f, -0.990602f, -0.f } },
		{ { -1.f, -0.f, 0.f }, { 0.75f, 0.5f }, { -1.f, -0.f, 0.f }, { 0.f, 0.f, 1.f }, { 0.f, -0.990602f, 0.136774f } },
		{ { 0.f, -0.f, 1.f }, { 1.f, 0.5f }, { 0.f, -0.f, 1.f }, { 0.707107f, 0.f, 0.707107f }, { 0.136774f, -0.990602f, -0.f } },
		{ { 0.f, -0.707107f, 0.707107f }, { 0.f, 0.75f }, { 0.f, -0.707107f, 0.707107f }, { 0.707107f, 0.f, -0.707107f }, { -0.52788f, -0.848984f, 0.02386f } },
		{ { 0.707107f, -0.707107f, -0.f }, { 0.25f, 0.75f }, { 0.707107f, -0.707107f, -0.f }, { -0.196116f, 0.f, -0.980581f }, { -0.400263f, -0.811914f, 0.424953f } },
		{ { -0.f, -0.707107f, -0.707107f }, { 0.5f, 0.75f }, { -0.f, -0.707107f, -0.707107f }, { -0.980581f, 0.f, 0.196116f }, { 0.086693f, -0.801277f, 0.59198f } },
		{ { -0.707107f, -0.707107f, 0.f }, { 0.75f, 0.75f }, { -0.707107f, -0.707107f, 0.f }, { 0.196116f, 0.f, 0.980581f }, { 0.427558f, -0.867282f, 0.254983f } },
		{ { 0.f, -0.707107f, 0.707107f }, { 1.f, 0.75f }, { 0.f, -0.707107f, 0.707107f }, { 0.707107f, 0.f, 0.707107f }, { 0.621876f, -0.782076f, 0.04034f } },
		{ { 0.f, -1.f, 0.f }, { 0.5f, 1.f }, { 0.f, -1.f, 0.f }, { -0.f, 0.f, 0.f }, { 0.f, -0.382683f, 0.92388f } }
	};

	static const std::vector<unsigned int> expectedIndices = {
		2, 0, 1,
		12, 11, 16,
		3, 0, 2,
		13, 12, 16,
		4, 0, 3,
		14, 13, 16,
		5, 0, 4,
		15, 14, 16,
		2, 1, 6,
		7, 2, 6,
		3, 2, 7,
		8, 3, 7,
		4, 3, 8,
		9, 4, 8,
		5, 4, 9,
		10, 5, 9,
		7, 6, 11,
		12, 7, 11,
		8, 7, 12,
		13, 8, 12,
		9, 8, 13,
		14, 9, 13,
		10, 9, 14,
		15, 10, 14
	};

	TestableSphere* sphere = new TestableSphere(4u, 4u, SphereShading::SMOOTH, ValuesRange::ONE_TO_ONE);

	const auto& v = sphere->getVertices();
	const auto& i = sphere->getIndices();

	REQUIRE(v.size() == expectedVertices.size());
	REQUIRE(i.size() == expectedIndices.size());

	for (size_t idx = 0; idx < v.size(); ++idx) {
		CheckVec3Equal(v[idx].Position, expectedVertices[idx].Position, TEST_EPSILON, "Position");
		CheckVec2Equal(v[idx].TexCoord, expectedVertices[idx].TexCoord, TEST_EPSILON, "TexCoord");
		CheckVec3Equal(v[idx].Normal, expectedVertices[idx].Normal, TEST_EPSILON, "Normal");
		CheckVec3Equal(v[idx].Tangent, expectedVertices[idx].Tangent, TEST_EPSILON, "Tangent");
		CheckVec3Equal(v[idx].Bitangent, expectedVertices[idx].Bitangent, TEST_EPSILON, "Bitangent");
	}

	for (size_t idx = 0; idx < i.size(); ++idx) {
		REQUIRE(i[idx] == expectedIndices[idx]);
	}
}